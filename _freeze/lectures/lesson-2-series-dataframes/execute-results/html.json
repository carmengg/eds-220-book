{
  "hash": "a2c2a793bf785f4cbf5cd2382630e500",
  "result": {
    "markdown": "# `pandas`\n\nIn this lesson we introduce the two core objects in the `pandas` library, the `pandas.Series` and the `pandas.DataFrame`. \n\n## `pandas`\n\n`pandas` is a Python package to wrangle and analyze tabular data. It is built on top of NumPy and has become the core tool for doing data analysis in Python. \n\nThe convention to import it is:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n\n# we will also import numpy \nimport numpy as np\n```\n:::\n\n\nThere is so much to learn about `pandas`. While we won't be able to cover every single functionality of this package in the next three lecutres, the goal is to get you started with the basic tools for data wrangling and give you a solid basis on which you can explore further. \n\n## Series\n\nThe first core data structure of pandas is the **series**. \nA series is a *one-dimensional* array of *indexed* data. A `pandas.Series` having an **index** is the main difference between a `pandas.Series` and a numpy array. See the difference:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# a numpy array\n# np.random.randn returns values from the std normal distribution\narr = np.random.randn(4) \nprint(type(arr))\nprint(arr, \"\\n\")\n\n# a pandas series made from the previous array\ns = pd.Series(arr)\nprint(type(s))\nprint(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'numpy.ndarray'>\n[-0.25619978 -0.29003821  0.86499254 -1.00247858] \n\n<class 'pandas.core.series.Series'>\n0   -0.256200\n1   -0.290038\n2    0.864993\n3   -1.002479\ndtype: float64\n```\n:::\n:::\n\n\n### Creating a `pandas.Series`\n\nThe basic method to create a `pandas.Series` is to call\n\n``` python\ns = pd.Series(data, index=index)\n```\n\nThe `data` parameter can be:\n\n- a [numpy array](https://numpy.org/doc/stable/reference/arrays.ndarray.html) or [a list](https://realpython.com/python-list/)\n- a [Python dictionary](https://realpython.com/lessons/dictionary-python/)\n- [a number](https://commons.wikimedia.org/wiki/File:Number-three.JPG)\n\nThe `index` parameter is a list of index labels.\n\nFor now, we will create a `pandas.Series` from a numpy array or list. To use this method we need to pass a numpy array (or a list of objects that can be converted to NumPy types) as `data` and a list of indices of the same length as data. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# a Series from a numpy array \npd.Series(np.arange(3), index=['a','b','c'])\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\na    0\nb    1\nc    2\ndtype: int64\n```\n:::\n:::\n\n\n The `index` parameter is optional. If we don't include it, the default is to make the index equal to `[0,...,len(data)-1]`. For example:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# a Series from a list of strings with default index\npd.Series(['EDS 220', 'EDS 222', 'EDS 223', 'EDS 242'])\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n0    EDS 220\n1    EDS 222\n2    EDS 223\n3    EDS 242\ndtype: object\n```\n:::\n:::\n\n\n#### From a dictionary\n\nRemember a dictionary is a set of key-value pairs. If we create a `pandas.Series` via a dictionary the keys will become the index and the values the corresponding data.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# construct dictionary\nd = {'a':0, 'b':1, 'c':2}\n\n# initialize a sries using a dictionary\npd.Series(d)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\na    0\nb    1\nc    2\ndtype: int64\n```\n:::\n:::\n\n\n#### From a number\nIf we only provide a number as the data for the series, we need to provide an index. The number will be repeated to match the length of the index.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\npd.Series(3.0, index = ['A', 'B', 'C'])\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nA    3.0\nB    3.0\nC    3.0\ndtype: float64\n```\n:::\n:::\n\n\n### Simple operations\n\nArithmetic operations work on series and also most NumPy functions. For example:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# define a series\ns = pd.Series([98,73,65],index=['Andrea', 'Beth', 'Carolina'])\n\n# divide each element in series by 10\nprint(s /10, '\\n')\n\n# take the exponential of each element in series\nprint(np.exp(s), '\\n')\n\n# notice this doesn't change the values of our series\nprint(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAndrea      9.8\nBeth        7.3\nCarolina    6.5\ndtype: float64 \n\nAndrea      3.637971e+42\nBeth        5.052394e+31\nCarolina    1.694889e+28\ndtype: float64 \n\nAndrea      98\nBeth        73\nCarolina    65\ndtype: int64\n```\n:::\n:::\n\n\nWe can also produce new `pandas.Series` with `True`/`False` values indicating whether the elements in a series satisfy a condition or not:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ns > 10\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nAndrea      True\nBeth        True\nCarolina    True\ndtype: bool\n```\n:::\n:::\n\n\nThis kind of simple conditions on `pandas.Series` will be key when we are selecting data from data frames.\n\n<!-- TO DO: ADD COMPARING VALUES OF A SERIES -->\n\n### Attributes & Methods\n`pandas.Series` have *many* attributes and methods, you can see a [full list in the `pandas` documentation](https://pandas.pydata.org/docs/reference/api/pandas.Series.html). For now we will cover two examples that have to do with identifying missing values.\n\n`pandas` represents a missing or NA value with `NaN`, which stands for not a number. Let's construct a small series with some NA values:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# series with NAs in it\ns = pd.Series([1, 2, np.NaN, 4, np.NaN])\n```\n:::\n\n\nA `pandas.Series` has an *attribute* called `hasnans` that returns `True` if there are any NaNs:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# check if series has NAs\ns.hasnans\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nTrue\n```\n:::\n:::\n\n\nThen we might be intersted in knowing which elements in the series are NAs. We can do this using the [`isna` method](https://pandas.pydata.org/docs/reference/api/pandas.Series.isna.html):\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ns.isna()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n0    False\n1    False\n2     True\n3    False\n4     True\ndtype: bool\n```\n:::\n:::\n\n\nWe can see the ouput is a `pd.Series` of boolean values indicating if an element in the row at the given index is NA (`True` = is NA) or not (`False` = not NA).\n\n:::{.callout-note}\n## moving on\nThere's much more to say about `pandas.Series`, but this is enought to get us going. At this point, we mainly want to know about `pandas.Series` because `pandas.Series` are the columns of `pandas.DataFrame`s.\n:::\n\n::: {.callout-caution}\n## slicing with `loc`\nNotice that when use slicing with `loc` we get both the start *and the end* of the indices we indicated. This is different to slicing in numpy arrays or lists where we do not get the element at the end of the slice. Compare the following:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(x)\n\n# slicing will return elements at indices 2 trhough 4 (inclusive)\nx[2:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n[2, 3, 4]\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# define a np array with integers from 0 to 9\ny = np.arange(10)\nprint(y)\n\n# slicing will return elements at indices 2 trhough 4 (inclusive)\ny[2:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4 5 6 7 8 9]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\narray([2, 3, 4])\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n z = pd.Series(y)\n print(z)\n\n# slicing will return elements with index labels 2 through 5 (inclusive)\n z.loc[2:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    0\n1    1\n2    2\n3    3\n4    4\n5    5\n6    6\n7    7\n8    8\n9    9\ndtype: int64\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n2    2\n3    3\n4    4\n5    5\ndtype: int64\n```\n:::\n:::\n\n\n::: \n\n## Data Frames\n\nThe Data Frame is the most used `pandas` object. It represents tabular data and we can think of it as a spreadhseet. Each column of a `pandas.DataFrame` is a `pandas.Series`. \n\n### Creating a `pandas.DataFrame`\nThere are [many ways of creating a `pandas.DataFrame`](https://pandas.pydata.org/docs/user_guide/dsintro.html#dataframe). \n\nWe already mentioned each column of a `pandas.DataFrame` is a `pandas.Series`. In fact, the `pandas.DataFrame` is a dictionary of `pandas.Series`, with each column name being the key and the column values being the key's value. Thus, we can create a `pandas.DataFrame` in this way:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# initialize dictionary with columns' data \nd = {'col_name_1' : pd.Series(np.arange(3)),\n     'col_name_2' : pd.Series([3.1, 3.2, 3.3]),\n     }\n\n# create data frame\ndf = pd.DataFrame(d)\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>col_name_1</th>\n      <th>col_name_2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>3.1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>3.2</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2</td>\n      <td>3.3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can change the index and column names by changing the `index` and `columns` attributes in the data frame. \n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# print original index\nprint(df.index)\n\n# change the index\ndf.index = ['a','b','c']\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRangeIndex(start=0, stop=3, step=1)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>col_name_1</th>\n      <th>col_name_2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>a</th>\n      <td>0</td>\n      <td>3.1</td>\n    </tr>\n    <tr>\n      <th>b</th>\n      <td>1</td>\n      <td>3.2</td>\n    </tr>\n    <tr>\n      <th>c</th>\n      <td>2</td>\n      <td>3.3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# print original column names\nprint(df.columns)\n\n# change column names \ndf.columns = ['C1','C2']\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndex(['col_name_1', 'col_name_2'], dtype='object')\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>C1</th>\n      <th>C2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>a</th>\n      <td>0</td>\n      <td>3.1</td>\n    </tr>\n    <tr>\n      <th>b</th>\n      <td>1</td>\n      <td>3.2</td>\n    </tr>\n    <tr>\n      <th>c</th>\n      <td>2</td>\n      <td>3.3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n",
    "supporting": [
      "lesson-2-series-dataframes_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}