{
  "hash": "6143291121ad8858277ffecf5ba4132f",
  "result": {
    "markdown": "---\n# do not execute cells\nexecute:\n  eval: false\n---\n\n<!--\nhttps://carpentries-incubator.github.io/geospatial-python/06-raster-intro.html\n-->\n\n# `rioxarray`\n\nIn this lesson we will introduce [`rioxarray`](https://corteva.github.io/rioxarray/stable/), a Python extension for `xarray` to manipulate `xarray.DataArray`s as rasters. \nThe name `rioxarray` stands for *raster input/output + xarray*. \nWe will use the `rioxarray`'s `rio` accessor to obtain raster information from an `xarray.DataArray` and do some raster manipulations (calculate NDVI). \n\n## Data\nThe raster files we will use today come from the [US National Agriculture Imagery Program (NAIP)](https://naip-usdaonline.hub.arcgis.com). \nNAIP images are are high-resolution aerial images with four spectral bands: Red, Green, Blue and Near-infrared (NIR). \nThe raster's we'll use today are from 2020.\n\nFor this lesson, I did some pre-processing of the data to separate the RGB bands from the NIR band and clipped a scene. \nThe data was accessed and pre-processed at [Microsoft's Planetary Computer NAIP data repository](https://planetarycomputer.microsoft.com/dataset/naip#overview).\n\n## Import .tif\n\nLet's start by loading the libraries we'll use: \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport rioxarray as rioxr\n\nimport geopandas as gpd\nfrom shapely.geometry import Polygon\n```\n:::\n\n\nThere are [multiple ways of opening a '.tif' file using `xarray` or `rioxarray`](https://corteva.github.io/rioxarray/html/getting_started/getting_started.html). \nUsing the `rioxarray.open_rasterio()` function to open the '.tif' file is a simple way to make sure all our geospatial data gets loaded correctly:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# load NIR tif file\nnir_fp = os.path.join(os.getcwd(),'data','naip','nir.tif')\nnir = rioxr.open_rasterio(nir_fp)\nnir\n```\n:::\n\n\n## `xr.DataArray` exploration\n\nFirst, let's verify the raster we loaded is an `xarray.DataArray`:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ntype(nir)\n```\n:::\n\n\nNotice we see all the components of an `xarray.DataArray`: its dimensions (band, y, x), the coordiantes for each dimension, and some attributes. \nWe can also directly access some of these attribues:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# print shape and data type\nprint('shape: ', nir.shape)\nprint('data type: ', nir.dtype, '\\n')\n```\n:::\n\n\nUsing the `.values` attribute we can get a quick view at the values at the corners in our data array. \n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nprint(type(nir.values))\nnir.values\n```\n:::\n\n\nWe can also plot our data:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nnir.plot()\n```\n:::\n\n\nNotice the coordinates on the x and y axes. \nThis map shows the light captured in the near-infrared spectrum by a sensor on a plane. \n**Can you guess where this?** \nIf you guessed Santa Barbara downtown, you guessed right! \n\n## `rio` accessor\n\nAn **accessor** in Python let's us access a different set of properties of an object.\nIn our case, we use the `.rio` accessor for `xarray.DataArray`s to access its raster properties. \nFor example, its number of bands, height, width, spatial bounding box, and CRS:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# check geospatial attributes\nprint('# bands: ', nir.rio.count)\nprint('height: ', nir.rio.height)\nprint('width: ', nir.rio.width, '\\n')\n\nprint('spatial bounding box: ')\nprint(nir.rio.bounds(), '\\n')\n\nprint('CRS: ', nir.rio.crs)\n```\n:::\n\n\n:::{.callout-note}\n# Other accessors\nWe have used accessors before, for example the `.str` and `.dt` accessors in `pandas`.\n:::\n\n## Multi-band raster\n\nLet's now import the RGB raster:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# open RGB raster\nrgb_fp = os.path.join(os.getcwd(),'data','naip','rgb.tif')\nrgb = rioxr.open_rasterio(rgb_fp)\nrgb\n```\n:::\n\n\nNotice this raster has three bands, instead of one. \nThis makes sense because we know these bands correspond tothe Red, Green and Blue bands of the image. \nWe can also check this information by looking directly at the attributes:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nprint('rgb shape: ', rgb.shape)\nprint('rgb # bands: ', rgb.rio.count)\n```\n:::\n\n\nLet's check the geospatial data too:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# check geospatial attributes\nprint('shape: ', rgb.shape)\nprint('data type: ', rgb.dtype)\nprint('# bands: ', rgb.rio.count)\nprint('CRS: ', rgb.rio.crs)\n\n# check if the CRSs of the rasters match\nprint( rgb.rio.crs == nir.rio.crs)\n```\n:::\n\n\nOn the last line we checked the nir and rgb rasters have the same ESPG:26911 CRS. \nThis is a projected CRS.\n\n<!--\n![Source: [spatialreference.org](https://spatialreference.org/ref/epsg/26911/)]()\n-->\n\nFinally, let's plot this raster.\nSince it has three bands, we can plot it as an image using the `.plot.imshow()` method, which will interpret the three bands of the object as RGB.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# parameters for plotting rasters\nsize = 6 # height in in of plot height\naspect = rgb.rio.width / rgb.rio.height # ratio of widht/height\n\n# plot three bands as RGB image\nrgb.plot.imshow(size=size, aspect=aspect)\n```\n:::\n\n\n## Box for clipping\n\nOur area of interest (aoi) for this lesson is a smaller region that includes only a few blocks around the NCEAS building. \nAn easy way to obtain coordinates for such a region:\n\n![Screenshot from geojson.io](/images/geojsonio-sb.png)\n\n1. go to  [https://geojson.io/](https://geojson.io/) website,\n2. zoom in until you find the NCEAS building in Santa Barbara, it might help to change to 'Satellite Streets' view on the bottom left corner, \n3. click on the rectangle icon on the right-side toolbar and draw a small region around the NCEAS buildng,\n4. the geoJSON code representing this area will appear in the code box,\n5. one option is two copy-paste this geoJSON into an empty text file and save such file with the .json extension, we could then read it in using `geopandas`\n6. instead, we will create our region of index by just *copy-pasting the list of points* and storing it as a variable:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# vertices of our aoi box\npoints = [[-119.70608227128903, 34.426300194372274],\n          [-119.70608227128903, 34.42041139020533],\n          [-119.6967885126002, 34.42041139020533],\n          [-119.6967885126002, 34.426300194372274],\n          [-119.70608227128903, 34.426300194372274]]\n```\n:::\n\n\nWe can then create a new `geopandas.GeoDataFrame`:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# create geodataframe with aoi \naoi = gpd.GeoDataFrame(geometry=[Polygon(points)],\n                           crs='epsg:4326')\naoi\n```\n:::\n\n\nLet's break this down a bit:\n\n- first, we use the `shapely`'s `Polygon()` function to create a polygon from our `points` list. \n- in `[Polygon(points)]` we put this polygon inside a list so we can form the geometry column of our new `gpd.GeoDataFrame`\n- we know all the geoJSON files have CRS equal to EPSG:4326/WGS 84, so we set the the CRS of our new `gpd.GeoDataFrame` to this.\n\n## Clip raster\n\nRemember: **if two geospatial sets will interact they need to be in the same CRS**.  \nIn our case, the aoi `gpd.GeoDataFrame` does not have the same CRS as the rasters:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# check CRss\nprint('aoi CRS: ', aoi.crs)\nprint('nir CRS: ', nir.rio.crs)\nprint('rgb CRS: ', rgb.rio.crs)\n```\n:::\n\n\nSo let's reproject:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# reproject aoi to rgb crs\naoi = aoi.to_crs(rgb.rio.crs)\nprint('matched crs?',  aoi.crs == rgb.rio.crs)\naoi.crs\n```\n:::\n\n\nAnd plot them together:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# plot aoi outline and RGB raster together\nfig, ax = plt.subplots()\nfig.set_size_inches((size, size*aspect)) # reuse size and aspect\nrgb.plot.imshow(ax=ax)\naoi.plot(ax=ax, alpha=0.6)\n```\n:::\n\n\nTo clip the raster using the aoi polygon we use the `.rio.clip_box()` method:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# clip rasters to aoi\nrgb_small = rgb.rio.clip_box(*aoi.total_bounds)\nnir_small = nir.rio.clip_box(*aoi.total_bounds)\n```\n:::\n\n\nNotice a few things:\n- we had to use the `.rio` accessor to access the `clip_box()` method \n- similarly to the `shapely.box()` function [we've used previously](https://carmengg.github.io/eds-220-book/lectures/lesson-13-standin.html#clipping-with-bounding-box), [`.rio.clip_box()` usual parameters](https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray.raster_dataset.RasterDataset.clip_box) are minx, miny, maxx, maxy. We are using the `*` asterisk as an unpacking operator to get these from the list `aoi.total_bounds`.\n\nLet's check our clipped data:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# check shape updates\nprint('original shape: ', rgb.shape)\nprint('reduced shape: ', rgb_small.shape)\n\n# plot with correct sizes\nsize = 4\naspect = rgb_small.rio.width/ rgb_small.rio.height\nrgb_small.plot.imshow(size=size, aspect=aspect)\n```\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# check shape updates\nprint('original shape: ', nir.shape)\nprint('reduced shape: ', nir_small.shape)\n\nnir_small.plot()\n```\n:::\n\n\n## Compute NDVI\n\nWe often want to combine values of and perform calculations on rasters to create a new output raster. \nIn our case, we are interested in computing the Normalized Difference Vegetation Index (NDVI) over our area of interest. \nThe NDVI is an index commonly used to check if an area has live green vegetation or not.\n\nAccording to the [Earth Observing System](https://eos.com/blog/ndvi-faq-all-you-need-to-know-about-ndvi/)\n> The results of the NDVI calculation range from -1 to 1. Negative values correspond to areas with water surfaces, manmade structures, rocks, clouds, snow; bare soil usually falls within 0.1-0.2 range; and plants will always have positive values between 0.2 and 1. Healthy, dense vegetation canopy should be above 0.5, and sparse vegetation will most likely fall within 0.2 to 0.5. \n\nThe NDVI is calculated using the NIR and red bands. \nThe formula is\n\n$NDVI = \\frac{NIR - Red}{NIR + Red}.$\n\nFirst, we need to select the red band:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nred = rgb_small.sel(band=1)\nred\n```\n:::\n\n\nTo be able to perform the calculation successfully, we will need to udpate the data type of our rasters:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nred16 = red.astype('int16')\nnir16 = nir_small.astype('int16')\nprint('RED: original dtype:', rgb_small.dtype, '.... converted dtype:', red16.dtype)\nprint('NIR: original dtype:', nir.dtype, '.... converted dtype:', nir16.dtype)\n```\n:::\n\n\nWe can perform raster calculations using the same arithmetic we use for `np.array`s (because, underneath it all, they are). \nSo our NDVI calculation is as follows:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# calculate and plot NDVI\nndvi = (nir16 - red16)/(nir16+red16)\nndvi.plot()\n```\n:::\n\n\nRemember that plants will always have positive NDVI values between 0.2 and 1. \nCan you spot the Courthouse?\n\n::: {.callout-warning}\n# Why change the data type?\nThe `uint8` (8-bit unsigned integer) is a very small data type that only holds integers from 0 up to 255. \nIn particular, calculations don't return what what we are used to when working with intgers ([they're done module 256](https://en.wikipedia.org/wiki/Modular_arithmetic)):\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nnp.uint8(150) + np.uint8(150)\n```\n:::\n\n\nIn the NDVI formula we have to add NIR + Red. \nIf both NIR and Red are very close to 255, when we add them, the calculation overflows the `uint8` data type and we don't get the expected results:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nx = (nir - red)/(nir + red)\nx.plot()\n```\n:::\n\n\nThis is why we need to manually convert both rasters into `int16`, which will be big enough to hold all the numbers that appear in the calculations.\n\nNotice too, that when we performed the NDVI calculation we did not get any warning, although we were overflowing the computation at every cell of our array. \nThis is can be an example of *failing silently*, where we don't get any warnings about the errors in our computation. \nThat's why it's so important to double-check our results!\n:::\n\n",
    "supporting": [
      "lesson-17-rioxarray_files"
    ],
    "filters": [],
    "includes": {}
  }
}