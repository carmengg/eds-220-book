[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EDS 220 - Working with Environmental Datasets",
    "section": "",
    "text": "Welcome!\nWelcome to the course materials for EDS 220 - Working with Environmental Datasets! This course is part of the UCSB Masters in Environmental Data Science.\nIn this website you will find the materials covered during lectures and discussion sections for the Fall 2023 term. This site will be under construction throughout the course."
  },
  {
    "objectID": "index.html#about",
    "href": "index.html#about",
    "title": "EDS 220 - Working with Environmental Datasets",
    "section": "About",
    "text": "About\nThis hands-on course explores widely used environmental data formats and Python libraries for analyzing diverse environmental data. Students will gain experience working with popular open data repositories and cloud platforms to source and analyze real-world environmental datasets. The course will also serve as an introduction to Python programming and provide opportunities to practice effective communication of the strengths and weaknesses of studentsâ€™ data products and analyses."
  },
  {
    "objectID": "index.html#instruction-team",
    "href": "index.html#instruction-team",
    "title": "EDS 220 - Working with Environmental Datasets",
    "section": "Instruction Team",
    "text": "Instruction Team\n\nInstructor\nCarmen Galaz GarcÃ­a (she/her/hers)\nE-mail: galaz-garcia@nceas.ucsb.edu\nOffice hour: Wednesday 3:30-4:30 pm, NCEAS classroom\nBest way to contact me: e-mail\n\n\nTA\nYutian Fang (she/her/hers)\nE-mail: yutianfang@bren.ucsb.edu\nOffice Hours: Thursday, 3-4 pm, Marine Science Institute office 1208.\nBest way to contact me: email"
  },
  {
    "objectID": "index.html#syllabus",
    "href": "index.html#syllabus",
    "title": "EDS 220 - Working with Environmental Datasets",
    "section": "Syllabus",
    "text": "Syllabus\nClick here to access the syllabus."
  },
  {
    "objectID": "index.html#calendar",
    "href": "index.html#calendar",
    "title": "EDS 220 - Working with Environmental Datasets",
    "section": "Calendar",
    "text": "Calendar\nThe following is our ideal calendar, the course content and calendar may be subject to change as the course progresses."
  },
  {
    "objectID": "index.html#about-this-website",
    "href": "index.html#about-this-website",
    "title": "EDS 220 - Working with Environmental Datasets",
    "section": "About this website",
    "text": "About this website\nThis website is created with Quarto and is published through GitHub pages. Click here to go to the websiteâ€™s GitHub repository."
  },
  {
    "objectID": "lectures/lesson-1-python-review.html#about",
    "href": "lectures/lesson-1-python-review.html#about",
    "title": "1Â  Python Review",
    "section": "1.1 About",
    "text": "1.1 About\nThis is a short reveiw about some core concepts in Python exemplified by objects in the numpy library."
  },
  {
    "objectID": "lectures/lesson-1-python-review.html#numpy",
    "href": "lectures/lesson-1-python-review.html#numpy",
    "title": "1Â  Python Review",
    "section": "1.2 numpy",
    "text": "1.2 numpy\nNumPy is one of the core packages for numerical computing in Python. Many of the packages we will use in this course use NumPyâ€™s arrays as their building blocks. Additionally, numpy objects have been optimized for processing, so computations on them are really fast and use less memory than doing the equivalent using base Python.\nIn this lesson we will use numpy to review some core concepts in Python youâ€™re already familiar with.\nFirst, letâ€™s start by importing the library:\n\nimport numpy as np"
  },
  {
    "objectID": "lectures/lesson-1-python-review.html#variables",
    "href": "lectures/lesson-1-python-review.html#variables",
    "title": "1Â  Python Review",
    "section": "1.3 Variables",
    "text": "1.3 Variables\nWe can think of a variable as a name we assign to a particular object in Python. For example:\n\n# assign a small array to variable a\na = np.array([[1,1,2],[3,5,8]])\n\nWhen we run the cell, we store the variables and their value. We can view a variableâ€™s value in two ways:\n\nrunning a cell with the variable name\nusing the print function to print the value\n\n\n# show the value\na\n\narray([[1, 1, 2],\n       [3, 5, 8]])\n\n\n\n# print the value \nprint(a)\n\n[[1 1 2]\n [3 5 8]]\n\n\n\n\n\n\n\n\nR and Python\n\n\n\nIn Python we use the equal sign = to assign values to variables in the same way the left-arrow <- is used in R.\n\n\n\n\n\n\n\n\nNaming Variables\n\n\n\nThere are many ways of constructing multi-word variable names as we can see in the previous example. In this course we will name variables using snake_case, where words are all in small caps and separated by underscores (ex: miles_run). This is the naming convention suggested by the Style Guide for Python Code."
  },
  {
    "objectID": "lectures/lesson-1-python-review.html#variables-and-objects",
    "href": "lectures/lesson-1-python-review.html#variables-and-objects",
    "title": "1Â  Python Review",
    "section": "1.4 Variables and Objects",
    "text": "1.4 Variables and Objects\nYou will often encounter the word object in Python documentation and tutorials. Informally speaking, an object is a bundle of properties and actions about something specific. For example, an object could represent a data frame with properties such as number of rows, names of columns, and date created, and actions suchs as selecting a specific row or adding a new column.\nA variable is the name we give a specific object, and the same object can be referenced by different variables. An analogy for this is the following: the Sun (object) is called â€œsolâ€ in Spanish and â€œsoleilâ€ in French, so two different names (variables) represent the same object. You can read more technical details about the difference between objects and variables in Python here.\nIn practice, we can often use the word variable and object interchangeably. I want to bring up what objects are so youâ€™re not caught off-guard with vocabulary youâ€™ll often encounter in the documentation, StackExchange, etc. Weâ€™ll often use the word object too (for example, in the next subsection!)."
  },
  {
    "objectID": "lectures/lesson-1-python-review.html#types",
    "href": "lectures/lesson-1-python-review.html#types",
    "title": "1Â  Python Review",
    "section": "1.5 Types",
    "text": "1.5 Types\nEvery object in Python has a type, the type tells us what kind of object it is. We can also call the type of an object, the class of an object (so class and type both mean what kind of object we have).\nWe can see the type/class of a variable/object by using the type function:\n\nprint(a)\ntype(a)\n\n[[1 1 2]\n [3 5 8]]\n\n\nnumpy.ndarray\n\n\nThe numpy.ndarray is the core object/data type in the NumPy pakcage. We can check the type of an entry in the array by indexing:\n\nprint(a[0,0])\ntype(a[0,0])\n\n1\n\n\nnumpy.int64\n\n\n\n\n\n\n\n\nCheck-in\n\n\n\nHow would you access the value 4 in the array a? Remember indexing in Python starts from 0!\n\n\nNotice the type of the value 1 in the array is numpy.int64 and not just the core Python integer type int. The NumPy type numpy.int64 is telling us 1 is an integer stored as a 64-bit number. NumPy has its own data types to deal with numbers depending on memory storage and floating point precision, click here to know see all the types.\nSince â€œeverything in Python is an objectâ€ and every object has a class, we will interact with SO MANY classes in this course. Often, knowing the type of an object is the first step to finding information to code what you want!"
  },
  {
    "objectID": "lectures/lesson-1-python-review.html#functions",
    "href": "lectures/lesson-1-python-review.html#functions",
    "title": "1Â  Python Review",
    "section": "1.6 Functions",
    "text": "1.6 Functions\nprint was our first example of a Python function. Functions take in a set of arguments, separated by commas, and use those arguments to create some output. There are several built-in funcions in Python, most of them are for interacting with the basic Python data types. You can see a list of them here.\n\n\n\n\n\n\nArgument or Parameter?\n\n\n\nWe can interchangeably say arguments or parameters. You will see argument more often in the documentation.\n\n\nWe can ask for information about a function by executing ? followed by the function name:\n\n?print\n\n\nThe first line is always the function showing all of its arguments in parenthesis. Then there is a short description of what the function does. And finally a list of the arguments and a brief explanation about each of them.\nYou can see there are different types of arguments inside the parenthesis. Roughly speaking, a function has two types of arguments:\n\nnon-optional arguments: arguments you need to specify for the function to do something, and\noptional arguments: arguments that are pre-filled with a default value by the function, but you can override them. Optional arguments appear inside the parenthesis () in the form optional_argument = default_value.\n\nExample:\nend is an argument in print with the default value a new line. We can change this argument so that finishes the line with ^_^ instead:\n\n# notice we had always used print withough specifying any value for the `end` argument\nprint('I am changing the default end argument of the print function', end=' ^_^')\n\nI am changing the default end argument of the print function ^_^"
  },
  {
    "objectID": "lectures/lesson-1-python-review.html#attributes-methods",
    "href": "lectures/lesson-1-python-review.html#attributes-methods",
    "title": "1Â  Python Review",
    "section": "1.7 Attributes & Methods",
    "text": "1.7 Attributes & Methods\nAn object in Python has attributes and methods. An attribute is a property of the object, some piece of information about it. A method is is a procedure associated with an object, so it is an action where the main ingredient is the object.\nFor example, these could be some attributes and methods a class cat:\n\n\n\n.\n\n\nMore formally, a method is a function that acts on the object it is part of.\nWe can access a variableâ€™s attributes and methods by adding a period . at the end of the variableâ€™s name. So we would write variable.variable_method() or variable.variable_attribute.\nExample\nNumPy arrays have many methods and attributes. Letâ€™s see some concrete examples.\n\n# define a 3x3 array\nvar = np.array([[1,2,3],[4,5,6],[7,8,9]])\nvar\n\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n\n\n\n# T is an example of attribute, it returns the transpose of var\nprint(var.T)\nprint(type(var.T))\n\n[[1 4 7]\n [2 5 8]\n [3 6 9]]\n<class 'numpy.ndarray'>\n\n\n\n# shape, another attribute, tells us the array dimensions\nprint(var.shape)\nprint(type(var.shape))\n\n(3, 3)\n<class 'tuple'>\n\n\n\n# ndim is an attribute hilding the number of array dimensions.\nprint(var.ndim)\nprint(type(var.ndim))\n\n2\n<class 'int'>\n\n\nNotice these attributes can have many different data types. Here we saw tuples and int, two of the core Python classes, and also a numpy array as attributes of var.\nNow some examples of methods:\n\n# the tolist method returns the array as a nested list of scalars\nvar.tolist()\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\n# the min method returns the minimum value in the array along an axis\nvar.min(axis=0)\n\narray([1, 2, 3])\n\n\n\n\n\n\n\n\nCheck-in\n\n\n\nWe can also call the min method without any parameters:\n\nvar.min()\n\n1\n\n\nWhat kind of parameter is axis in our previous call of the var method?\n\n\nRemember, methods are functions associated to an object. We can check this!\n\ntype(var.tolist)\n\nbuiltin_function_or_method\n\n\n\ntype(var.min)\n\nbuiltin_function_or_method\n\n\nYou can see a complete list of NumPy arrayâ€™s methods and attributes in the documentation.\n\n\n\n\n\n\nR and Python\n\n\n\nIn R we donâ€™t use methods within an object. Rather, functions are extrinsic to (outside) the objects they are acting on. In R, for example, there would be two separate items: the variable var and a separate function min that gets var as a parameter:\n# this is R code\nvar <- array(c(1,4,7,2,5,8,3,6,9), dim =c(3,3))\nmin(var)\nUsing the pipe operator % in Râ€™s tidyverse is closer to the dot . in Python:\n# this is R code\nvar <- array(c(1,4,7,2,5,8,3,6,9), dim =c(3,3))\nvar % min()\nWhat happens here is that the pipe % is passing var to the min() function as its first argument. This is essentially what happens in Python when a function is a method of a class:\n# this is Python code\nvar = np.array([[1,2,3],[4,5,6],[7,8,9]])\nvar.min()\nWhen working in Python, remember that methods are functions that are part of an object and a method uses the object it is part of to produce some information."
  },
  {
    "objectID": "lectures/lesson-1-python-review.html#exercises",
    "href": "lectures/lesson-1-python-review.html#exercises",
    "title": "1Â  Python Review",
    "section": "1.8 Exercises",
    "text": "1.8 Exercises\n\n\n\n\n\n\nExercise 1\n\n\n\nSuppose we have a class tree, make a diagram similar to the cat class diagram showing 3 attributes for the class and 3 methods.\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nConsider the following code:\nimport numpy as np\n\n?np.ones\n\n\nabc = np.ones([3,2], dtype=np.int8)\nprint(abc)\n\nx = abc.mean()\nprint(x)\n\n[[1 1]\n [1 1]\n [1 1]]\n1.0\n\n\nComplete the following paragraph using the given words:\n\n\n\n.\n.\n.\n.\n\n\n\n\nclass\nfunction\nobject\nmethod\n\n\nvariable\nnon-default\ndata-type\ndefault\n\n\npackage\nattribute\noutout\nparameter(s)\n\n\n\nabc is a ________ assigned to the NumPy ________ np.ones([3,2]). We construct np.ones([3,2]) by calling a ________ from the NumPy ________. [3,2] and np.int8 are ________ we pass to the np.ones ________. np.int8 is a ________ parameter of np.ones. abc.mean is an ________ of abc and x is its ________.\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\n\nRead the print function help. What is the type of the argument sep? Is this a default or non-default argument? Why?\nCreate two new variables, one with the integer value 77 and another one with the string 99.\nUse your variables to print 77%99%77 by changing the value of one of the default arguments in print.\n\n\n\n\nvar = np.array([2,3,5,7,11,13]).reshape([2,3])\nvar\n\narray([[ 2,  3,  5],\n       [ 7, 11, 13]])"
  },
  {
    "objectID": "lectures/lesson-2-pandas-basics.html#about",
    "href": "lectures/lesson-2-pandas-basics.html#about",
    "title": "2Â  Pandas Fundamentals",
    "section": "2.1 About",
    "text": "2.1 About\nIn this lesson we will cover the two core objects in the pandas library the series and the data frame. We will also learn methods to subset, select, and add data to our data frames, as well as some basic plotting with matplotlib.\nThere is so much about pandas. While we wonâ€™t be able to cover every single functionality of this package in the next three lecutres, the goal is to get you started with the basic tools for tabular data analysis and give you a solid basis on which you can explore further."
  },
  {
    "objectID": "lectures/lesson-2-pandas-basics.html#pandas",
    "href": "lectures/lesson-2-pandas-basics.html#pandas",
    "title": "2Â  Pandas Fundamentals",
    "section": "2.2 pandas",
    "text": "2.2 pandas\npandas is a Python package to wrangle and analyze tabular data. It is built on top of NumPy and has become the core tool for doing data analysis in Python.\nThe convention to import it is:\n\nimport pandas as pd\n\n# we will also import numpy \nimport numpy as np"
  },
  {
    "objectID": "lectures/lesson-2-pandas-basics.html#series",
    "href": "lectures/lesson-2-pandas-basics.html#series",
    "title": "2Â  Pandas Fundamentals",
    "section": "2.3 Series",
    "text": "2.3 Series\nThe first core data structure of pandas is the series. A series is one-dimensional array of indexed data. A pandas.Series having an index is the main difference between a pandas.Series and a numpy array.\nExample 1\n\n# a numpy array\narr = np.random.randn(5) #np.random.randn returns values from the std normal distribution\nprint(type(arr))\nprint(arr, \"\\n\")\n\n# a pandas series\ns = pd.Series(arr)\nprint(type(s))\nprint(s)\n\n<class 'numpy.ndarray'>\n[ 1.07809409  1.10694321 -1.66192954  1.68286146 -0.35011539] \n\n<class 'pandas.core.series.Series'>\n0    1.078094\n1    1.106943\n2   -1.661930\n3    1.682861\n4   -0.350115\ndtype: float64\n\n\n\n2.3.1 How to create a pandas.Series\nThe basic method to create a pandas.Series is to call\ns = pd.Series(data, index=index)\nThe data parameter can be:\n\na numpy array or a list\na Python dictionary\na number\n\nThe index parameter is a list of index labels.\n\n2.3.1.1 From a numpy array or list\nTo use this method we need to pass a numpy array (or any list of objects) as data and a list of indices of the same length as data.\n\n# a Series from a numpy array \npd.Series(np.arange(3), index=['a','b','c'])\n\na    0\nb    1\nc    2\ndtype: int64\n\n\nThe index parameter is optional. If we donâ€™t include it the default is to make the index be [0,...,len(data)-1] (see Example 1).\n\n# a Series from a list of strings with default index\npd.Series(['EDS 220', 'EDS 222', 'EDS 223', 'EDS 242'])\n\n0    EDS 220\n1    EDS 222\n2    EDS 223\n3    EDS 242\ndtype: object\n\n\n\n\n2.3.1.2 From a dictionary\nRemember a dictionary is a set of key-value pairs. If we create a pandas.Series via a dictionary the keys will become the index and the values the corresponding data.\n\n# construct dictionary\nd = {'a':0, 'b':1, 'c':2}\n\n# initialize a sries using a dictionary\npd.Series(d)\n\na    0\nb    1\nc    2\ndtype: int64\n\n\n\n\n2.3.1.3 From a number\nIf we only provide a number as the data for the series, we need to provide an index. The number will be repeated to math the length of the index.\n\npd.Series(3.0, index = ['A', 'B', 'C'])\n\nA    3.0\nB    3.0\nC    3.0\ndtype: float64\n\n\n\n\n\n2.3.2 Arithmetic Operations\nArithmetic operations work on series and also most NumPy functions. For example:\n\n# define a series\ns = pd.Series([98,73,65],index=['Andrea', 'Beth', 'Carolina'])\n\n# divide each element in series by 10\nprint(s /10, '\\n')\n\n# take the exponential of each element in series\nprint(np.exp(s), '\\n')\n\n# notice this doesn't change the values of our object\nprint(s)\n\nAndrea      9.8\nBeth        7.3\nCarolina    6.5\ndtype: float64 \n\nAndrea      3.637971e+42\nBeth        5.052394e+31\nCarolina    1.694889e+28\ndtype: float64 \n\nAndrea      98\nBeth        73\nCarolina    65\ndtype: int64\n\n\nThereâ€™s much more to say about pandas.Series, but this is enought to get us going. Mainly, we want to know about pandas.Series because they will be the columns of our pandas.DataFrame.\n\n\n2.3.3 Indexing\n\n2.3.3.1 By labelâ€¦\nIndexing by label means we want to select data from our series using the label names in the seriesâ€™ index. There are two ways of indexing by label:\n\n2.3.3.1.1 â€¦ with []\nWe can use [] to acess specific values by label in the same way as we do in a dictionary: series['index_label']\n\n# initalize series\ns = pd.Series(np.arange(5), index=['a','b','c','d','e'])\nprint(s, '\\n')\n\n# access element corresponding to label 'b'\ns['b']\n\na    0\nb    1\nc    2\nd    3\ne    4\ndtype: int64 \n\n\n\n1\n\n\n\n\n2.3.3.1.2 â€¦ with loc\nThis will be our preferred method in the course. We can do a many things with it:\n\n# access a specific element by label\ns.loc['b']\n\n1\n\n\n\n# access a few elements by label\ns.loc[['a','c','e']]\n\na    0\nc    2\ne    4\ndtype: int64\n\n\n\n# select based on True/False values\ns.loc[s>3]\n\ne    4\ndtype: int64\n\n\n\n# slice the series using the labels\ns.loc['b':'d']\n\nb    1\nc    2\nd    3\ndtype: int64\n\n\n\n\n\n\n\n\nslicing with loc\n\n\n\nNotice that when use slicing with loc we get both the start and the end of the indices we indicated. This is different to slicing in numpy arrays or lists where we do not get the element at the end of the slice. Compare the following:\n\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(x)\n\n# slicing will return elements at indices 2 trhough 4 (inclusive)\nx[2:5]\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n[2, 3, 4]\n\n\n\n# define a np array with integers from 0 to 9\ny = np.arange(10)\nprint(y)\n\n# slicing will return elements at indices 2 trhough 4 (inclusive)\ny[2:5]\n\n[0 1 2 3 4 5 6 7 8 9]\n\n\narray([2, 3, 4])\n\n\n\n z = pd.Series(y)\n print(z)\n\n# slicing will return elements with index labels 2 through 5 (inclusive)\n z.loc[2:5]\n\n0    0\n1    1\n2    2\n3    3\n4    4\n5    5\n6    6\n7    7\n8    8\n9    9\ndtype: int64\n\n\n2    2\n3    3\n4    4\n5    5\ndtype: int64\n\n\n\n\n\n\n\n2.3.3.2 By position\nIndexing by position means we want to select data from our series based on where it is within the series.\nWe can access a value by position using the iloc method. iloc stands for integer-location based indexing. This is the same kind of indexing we do in 1-dimensional numpy arrays or lists, where we use integers to access elements in the array and the index starts from 0.\n\n# initialize series\ns = pd.Series(np.arange(10,13), index=['a','b','c'])\nprint(s, '\\n')\n\n# access element at index 2 (third element in series)\ns.iloc[2]\n\na    10\nb    11\nc    12\ndtype: int64 \n\n\n\n12\n\n\nIf we try to use iloc with a label from our index we will get an error. Notice the TypeError: Cannot index by location with a non-integer key.\n\n\n\n.\n\n\n\n\n\n\n\n\niloc vs.Â loc\n\n\n\nAt the beginning the difference between iloc and loc can be confusing. Remember the i in iloc stands for integer-location, so this function only uses integers to retrieve information from the series. Moreover, remember iloc indexing works in the same way as indexing for Python lists.\nIf you want to dive deeper, this is a great discussion about the difference between iloc and loc: Stackoverflow - How are iloc and loc different?"
  },
  {
    "objectID": "lectures/lesson-2-pandas-basics.html#data-frames",
    "href": "lectures/lesson-2-pandas-basics.html#data-frames",
    "title": "2Â  Pandas Fundamentals",
    "section": "2.4 Data Frames",
    "text": "2.4 Data Frames"
  },
  {
    "objectID": "lectures/lesson-2-pandas-basics.html#selecting-data",
    "href": "lectures/lesson-2-pandas-basics.html#selecting-data",
    "title": "2Â  Pandas Fundamentals",
    "section": "2.5 Selecting data",
    "text": "2.5 Selecting data"
  },
  {
    "objectID": "lectures/lesson-2-pandas-basics.html#basic-matplotlib",
    "href": "lectures/lesson-2-pandas-basics.html#basic-matplotlib",
    "title": "2Â  Pandas Fundamentals",
    "section": "2.6 Basic Matplotlib",
    "text": "2.6 Basic Matplotlib"
  },
  {
    "objectID": "lectures/lesson-2-pandas-basics.html#resources",
    "href": "lectures/lesson-2-pandas-basics.html#resources",
    "title": "2Â  Pandas Fundamentals",
    "section": "2.7 Resources",
    "text": "2.7 Resources\nðŸ“– Pandas documentation - User Guide\nðŸ“– Python for Data Analysis, 3E - Getting started with pandas"
  }
]