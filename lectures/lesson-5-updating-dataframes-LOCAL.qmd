# Updating dataframes

```{python}
import pandas as pd

# will use this to create some random numbers
import random

# read in data
penguins = pd.read_csv('https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/inst/extdata/penguins.csv')

# look at dataframe's head
penguins.head()
```

Example:

Suppose we want to create a new column where the body mass is in kilograms instead of grams, so we need to divide the `body_mass_g` by 1000. 

```{python}
# add a new column body_mass_kg 
# sane syntax as adding a new key to a dictionary
penguins['body_mass_kg'] = penguins.body_mass_g/1000

# confirm the new column is the data frame
print('body_mass_kg' in penguins.columns)

# take a look at the new column
penguins.head()
```


Notice the new column got added at the end. If we want to insert a new column at a particular position we use the data frame method `insert()`:
```python
df.insert(loc = integer_index,  # location of new column
          column = 'new_col_name', 
          value = new_col_values)
```

Example: 

Suppose each penguin observation gets a unique identifier as a three digit number. We want to add this column, at the beginning of the data frame. We can use `insert` to do this:

```{python}
# create random 3-digit codes
# random.sample used for random sampling wo replacement
codes = random.sample(range(100,1000), len(penguins))

# insert codes at the front of data frame = index 0
penguins.insert(loc=0, 
                column = 'code',
                value = codes)
        
penguins.head()
```

<!--
Moving columns: pop, then insert

df.insert(0, 'name', df.pop('name'))
https://stackoverflow.com/questions/35321812/move-column-in-pandas-dataframe

Inserting at a particular location.

df.columns.get_loc()
-->

:::{.callout-note}
## `pd.DataFrames` and dictionaries
Remember we talked about how a `pandas.DataFrame` could be seen as a dictionary of its columns. The most basic way of adding a new column to a data frame is the same way of adding a new key-value pair to a dictionary:
```python
# adding a new key-value pair to a dictionary
# same as adding a new column in pandas
dict[new_key] = new_value
```
:::

## Adding multiple columns

We can assign multiple columns in the same call by using the data frame's `assign()` method. The general syntax is:
```python
df.assign( new_col1_name = new_col1_values, 
           new_col2_name = new_col2_values)
```
Notice the new column names are not strings, we declare them as if we were creating variables.

Example:

Suppose we want to add these new columns: 
- flipper length converted from mm to cm, and
- a code representing the observer.
We can do this using `assign()`:

```{python}
# create new columns in the data frame
# random.choices used for random sampling with replacement
# need to reassign output of assign() to update the data frame
penguins = penguins.assign( flipper_length_cm = penguins.flipper_length_mm /10, 
                            observer =   random.choices(['A','B','C'], k=len(penguins)))
# look at result
penguins.head()
```

## Removing columns

We can remove columns using the [`drop()` method for data frames](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop.html), the syntax is:
```python
df.drop(columns = col_names)
```
where `col_names` can be single column name (str) ot a list of column names. 

Example:

Now that we updated the units for flipper length and body mass, it makes sense to remove the previous columns to avoid duplicate information. We can do this using `drop()`:

```{python}
# use a list of column names
# reassign output of drop() to dataframe to update it
penguins = penguins.drop(columns=['flipper_length_mm','body_mass_g'])

# check columns
print(penguins.columns)
```

<!--
## Reordering columns and updating names
-->

## Updating values

Sometimes we want to update certain value within our data frame. We'll review some methods and best practices to do that in this section. 

### A single value
We can access a single value in a `pd.DataFrame` using the locators
- [`at[]`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.at.html) to select by labels, or
- [`iat[]`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.at.html) to select by position. 


The syntax for `at[]` is:
```python
df.at[single_index_value, 'column_name']
```
Think of `at[]` as the equivalent to `loc[]` when trying to access a single value.

Example:
Let's say we want to know what was the bill length of the penguin in the fourth row. We can access that using `at[]`:

```{python}
# access value at row with index=3 and column='bill_length_mm'
penguins.at[3,'bill_length_mm']
```

We get this is an NA. Maybe we want to update it to 38.3 mm. We can do this with `at[]` too:
```{python}
# update NA to 38.3
penguins.at[3,'bill_length_mm'] = 38.3

# we can check it was updated
penguins.head()
```

If we want to access a single value by position as we do with `iloc[]` we use the `iat[]` locator.

### Multiple values in a column

What if we want to update multiple values in a column?

When we only want to update some values in a column we can do this by select this data using `loc` (if selecting by labels) or `iloc` (if selecting by position). The general sytanx is
```python
# modifies data in place
df.loc[row_selection, col_name] = new_values
```
where `row_selection` is the rows we want to update, `col_name` is a single column name, and `new_values` is the new value or values we want. If using multiple values, this the `new_values` must be of the same length as the number of rows selected, 

Suppose, for example, that we want to update the "male" tag to "M".

```{python}
# select rows with sex=male and update the values in the sex column
penguins.loc[penguins.sex=='male', 'sex'] = 'M'

# check changes
penguins.head()
```


## `SettingWithCopyWarning` I

Suppose we want to similarly update the 'female' values in the sex column to 'F'. This is an example of another way we might try to do it, but it won't update our dataframe:

```{python}
# select rows and columns with two selection brackets [][] (chained indexing), instead of loc[]
# then trying to update the values
penguins[penguins.sex=='female']['sex'] = 'F'
```

When we select the data we want to update using **chained indexing** (`[][]`) instead of `loc[]` we get a `SettingWithCopyWarning`. *This is not an error*, `pandas` is trying to alert us to a potential bug, in this case that we did not update our dataframe:

```{python}
# no values were updated
penguins.head()
```

<!-- MAKE SOME DIAGRAMS LIKE DATAQUEST https://www.dataquest.io/blog/settingwithcopywarning/ -->

To see what is going on we need to understand that some `pandas` operations return a view to your data, while others return a **copy** of your data.

- **Views** are actual subsets of the original data, when we update them, we are modifying the original data frame. 

- **Copies** are unique objects, independent of our original data frames. When we update a copy we are not modifying the original data frame. 

Depending on what we are trying to do we might want to modify the original dataframe or we might want to modify a copy. 

::: {.callout-warning}
The `SettingWithCopyWarning` is letting us know our code is ambiguous and we need to double check the code is doing what we intended. 
:::

**Check-in** 
Update the 'female' values in the `penguins` data frame to 'F'. Don't use chained indexing

```{python}
# no chained indexing in assignment = no warning
penguins.loc[penguins.sex=='female','sex'] = 'F'

# notice the values were updated now
penguins.head()
```

## `SettingWithCopyWarning` II



assigning to the product of chained indexing has inherently unpredictable results.

Another 