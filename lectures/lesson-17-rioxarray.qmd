# `rioxarray`

In this lesson we will introduce [`rioxarray`](https://corteva.github.io/rioxarray/stable/), a Python extension for `xarray` to manipulate `xarray.DataArray`s as rasters. 
The name `rioxarray` stands for *raster input/output + xarray*. 
We will use the `rioxarray`'s `rio` accessor to obtain raster information from an `xarray.DataArray` and do some raster manipulations (calculate NDVI). 

## Data
The raster files we will use today come from the [US National Agriculture Imagery Program (NAIP)](https://naip-usdaonline.hub.arcgis.com). 
NAIP images are are high-resolution aerial images with four spectral bands: Red, Green, Blue and Near-infrared (NIR). 
The raster's we'll use today are from 2020.

For this lesson, I did some pre-processing of the data to separate the RGB bands from the NIR band and clipped a scene. 
The data was accessed and pre-processed at [Microsoft's Planetary Computer NAIP data repository](https://planetarycomputer.microsoft.com/dataset/naip#overview).

## Import .tif

Let's start by loading the libraries we'll use: 

```{python}
import os
import matplotlib.pyplot as plt

import rioxarray as rioxr

import geopandas as gpd
from shapely.geometry import Polygon
```

There are [multiple ways of opening a '.tif' file using `xarray` or `rioxarray`](https://corteva.github.io/rioxarray/html/getting_started/getting_started.html). 
Using the `rioxarray.open_rasterio()` function to open the '.tif' file is a simple way to make sure all our geospatial data gets loaded correctly:

```{python}
# load NIR tif file
nir_fp = os.path.join(os.getcwd(),'data','naip','nir.tif')
nir = rioxr.open_rasterio(nir_fp)
nir
```

## `xr.DataArray` exploration

First, let's verify the raster we loaded is an `xarray.DataArray`:

```{python}
type(nir)
```

Notice we see all the components of an `xarray.DataArray`: its dimensions (band, y, x), the coordiantes for each dimension, and some attributes. 
We can also directly access some of these attribues:

```{python}
# print shape and data type
print('shape: ', nir.shape)
print('data type: ', nir.dtype, '\n')
```

Using the `.values` attribute we can get a quick view at the values at the corners in our data array. 

```{python}
print(type(nir.values))
nir.values
```

We can also plot our data:

```{python}
nir.plot()
```

Notice the coordinates on the x and y axes. 
This map shows the light captured in the near-infrared spectrum by a sensor on a plane. 
**Can you guess where this?** 
If you guessed Santa Barbara downtown, you guessed right! 

## `rio` accessor

An **accessor** in Python let's us access a different set of properties of an object.
In our case, we use the `.rio` accessor for `xarray.DataArray`s to access its raster properties. 
For example, its number of bands, height, width, spatial bounding box, CRS, and affine transformation:

```{python}
print('# bands: ', nir.rio.count)
print('height: ', nir.rio.height)
print('width: ', nir.rio.width, '\n')

print('spatial bounding box: ')
print(nir.rio.bounds(), '\n')

print('affine transformation: ')
print(nir.rio.transform(), '\n')

print('CRS: ', nir.rio.crs)
```
 

:::{.callout-note}
# Other accessors
We have used accessors before, for example the `.str` and `.dt` accessors in `pandas`.
:::

## Multi-band raster

Let's now import the RGB raster:
```{python}
# open RGB raster
rgb_fp = os.path.join(os.getcwd(),'data','naip','rgb.tif')
rgb = rioxr.open_rasterio(rgb_fp)
rgb
```

Notice this raster has three bands, instead of one. 
This makes sense because we know these bands correspond tothe Red, Green and Blue bands of the image. 
We can also check this information by looking directly at the attributes:

```{python}
print('rgb shape: ', rgb.shape)
print('rgb # bands: ', rgb.rio.count)
```

Let's check the geospatial data too:

```{python}
print('shape: ', rgb.shape)
print('data type: ', rgb.dtype)
print('# bands: ', rgb.rio.count)
print('CRS: ', rgb.rio.crs)

# check if the CRSs of the rasters match
print( rgb.rio.crs == nir.rio.crs)
```

On the last line we checked the nir and rgb rasters have the same ESPG:26911 CRS. 
This is a projected CRS:

![Source: [spatialreference.org](https://spatialreference.org/ref/epsg/26911/)]()

Finally, let's plot this raster.
Since it has three bands, we can plot it as an image using the `.plot.imshow()` method, which will interpret the three bands of the object as RGB.

```{python}
rgb.plot.imshow(figsize=(8,8))
```

## Box for clipping

Our area of interest (aoi) for this lesso is a smaller region that includes only a few blocks around the NCEAS building. 
An easy way to obtain coordinates for such a region:

![]()

1. go to  [https://geojson.io/](https://geojson.io/) website,
2. zoom in until you find the NCEAS building in Santa Barbara, it might help to change to 'Satellite Streets' view on the bottom left corner, 
3. click on the rectangle icon on the right-side toolbar and draw a small region around the NCEAS buildng,
4. the geoJSON code representing this area will appear in the code box,
5. one option is two copy-paste this geoJSON into an empty text file and save such file with the .json extension, we could then read it in using `geopandas`
6. instead, we will create our region of index by just *copy-pasting the list of points* and storing it as a variable:

```{python}
points = [[-119.70608227128903, 34.426300194372274],
          [-119.70608227128903, 34.42041139020533],
          [-119.6967885126002, 34.42041139020533],
          [-119.6967885126002, 34.426300194372274],
          [-119.70608227128903, 34.426300194372274]]
```

We can then create a new `geopandas.GeoDataFrame`:

```{python}
aoi = gpd.GeoDataFrame(geometry=[Polygon(points)],
                           crs='epsg:4326')
aoi
```

Let's break this down a bit:

- first, we use the `shapely`'s `Polygon()` function to create a polygon from our `points` list. 
- in `[Polygon(points)]` we put this polygon inside a list so we can form the geometry column of our new `gpd.GeoDataFrame`
- we know all the geoJSON files have CRS equal to EPSG:4326/WGS 84, so we set the the CRS of our new `gpd.GeoDataFrame` to this.

## Clip raster

Remember: **if two geospatial sets will interact they need to be in the same CRS**.  
In our case, the aoi `gpd.GeoDataFrame` does not have the same CRS as the rasters:

```{python}
print('aoi CRS: ', aoi.crs)
print('nir CRS: ', nir.rio.crs)
print('rgb CRS: ', rgb.rio.crs)
```

So let's reproject:
```{python}
aoi = aoi.to_crs(rgb.rio.crs)
print('matched crs?',  aoi.crs == rgb.rio.crs)
aoi.crs
```

And plot them together:

```{python}
fig, ax = plt.subplots()
fig.set_size_inches((8,8))
rgb.plot.imshow(ax=ax)
aoi.plot(ax=ax, alpha=0.6)
```


```{python}
rgb_small = rgb.rio.clip_box(*aoi.total_bounds)
nir_small = nir.rio.clip_box(*aoi.total_bounds)
```


```{python}
print('original shape: ', rgb.shape)
print('reduced shape: ', rgb_small.shape)
rgb_small.plot.imshow()
```


```{python}

print('original shape: ', nir.shape)
print('reduced shape: ', nir_small.shape)
nir_small.plot()
```