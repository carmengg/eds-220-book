# Pandas Fundamentals

## About
In this lesson we cover the two core objects in the `pandas` library the series and the data frame. We will also learn methods to subset, select, and add data to our data frames, as well as some basic plotting with matplotlib.

There is so much to learn about `pandas`. While we won't be able to cover every single functionality of this package in the next three lecutres, the goal is to get you started with the basic tools for data wrangling and give you a solid basis on which you can explore further. 

## `pandas`

`pandas` is a Python package to wrangle and analyze tabular data. It is built on top of NumPy and has become the core tool for doing data analysis in Python. 

The convention to import it is:

```{python}
import pandas as pd

# we will also import numpy 
import numpy as np
```

## Series

The first core data structure of pandas is the **series**. 
A series is a *one-dimensional* array of *indexed* data. A `pandas.Series` having an **index** is the main difference between a `pandas.Series` and a numpy array. See the difference:

```{python}
# a numpy array
# np.random.randn returns values from the std normal distribution
arr = np.random.randn(4) 
print(type(arr))
print(arr, "\n")

# a pandas series made from the previous array
s = pd.Series(arr)
print(type(s))
print(s)
```


### How to create a `pandas.Series`

The basic method to create a `pandas.Series` is to call

``` python
s = pd.Series(data, index=index)
```

The `data` parameter can be:

- a [numpy array](https://numpy.org/doc/stable/reference/arrays.ndarray.html) or [a list](https://realpython.com/python-list/)
- a [Python dictionary](https://realpython.com/lessons/dictionary-python/)
- [a number](https://commons.wikimedia.org/wiki/File:Number-three.JPG)

The `index` parameter is a list of index labels.

#### From a numpy array or list

To use this method we need to pass a numpy array (or a list of objects that can be converted to NumPy types) as `data` and a list of indices of the same length as data. 

```{python}
# a Series from a numpy array 
pd.Series(np.arange(3), index=['a','b','c'])
```


 The `index` parameter is optional. If we don't include it, the default is to make the index equal to `[0,...,len(data)-1]`. For example:

```{python}
# a Series from a list of strings with default index
pd.Series(['EDS 220', 'EDS 222', 'EDS 223', 'EDS 242'])
```


#### From a dictionary

Remember a dictionary is a set of key-value pairs. If we create a `pandas.Series` via a dictionary the keys will become the index and the values the corresponding data.

```{python}
# construct dictionary
d = {'a':0, 'b':1, 'c':2}

# initialize a sries using a dictionary
pd.Series(d)
```

#### From a number
If we only provide a number as the data for the series, we need to provide an index. The number will be repeated to match the length of the index.

```{python}
pd.Series(3.0, index = ['A', 'B', 'C'])
```


### Arithmetic Operations

Arithmetic operations work on series and also most NumPy functions. For example:

```{python}
# define a series
s = pd.Series([98,73,65],index=['Andrea', 'Beth', 'Carolina'])

# divide each element in series by 10
print(s /10, '\n')

# take the exponential of each element in series
print(np.exp(s), '\n')

# notice this doesn't change the values of our series
print(s)

```

There's much more to say about `pandas.Series`, but this is enought to get us going. Mainly, we want to know about `pandas.Series` because they will be the columns of our `pandas.DataFrame`.

### Attributes & Methods
`pandas.Series` have *many* attributes and methods, you can see a [full list in the `pandas` documentation](https://pandas.pydata.org/docs/reference/api/pandas.Series.html). For now we will cover two examples that have to do with identifying missing values.

`pandas` represents a missing or NA value with `NaN`, which stands for not a number. Sometime


### Indexing

#### By label...

Indexing by label means we want to select data from our series using the label names in the series' index. There are two ways of indexing by label:

##### ... with `[]`

We can use `[]` to acess specific values by label in the same way as we do in a dictionary: `series['index_label']`

```{python}
# initalize series
s = pd.Series(np.arange(5), index=['a','b','c','d','e'])
print(s, '\n')

# access element corresponding to label 'b'
s['b']
```

##### ... with `loc`
This will be our preferred method in the course. We can do a many things with it:

```{python}
# access a specific element by label
s.loc['b']
```
```{python}
# access a few elements by label
s.loc[['a','c','e']]
```

```{python}
# select based on True/False values
s.loc[s>3]
```

```{python}
# slice the series using the labels
s.loc['b':'d']
```
::: {.callout-caution}
## slicing with `loc`
Notice that when use slicing with `loc` we get both the start *and the end* of the indices we indicated. This is different to slicing in numpy arrays or lists where we do not get the element at the end of the slice. Compare the following:

```{python}
x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(x)

# slicing will return elements at indices 2 trhough 4 (inclusive)
x[2:5]
```

```{python}
# define a np array with integers from 0 to 9
y = np.arange(10)
print(y)

# slicing will return elements at indices 2 trhough 4 (inclusive)
y[2:5]
```

```{python}
 z = pd.Series(y)
 print(z)

# slicing will return elements with index labels 2 through 5 (inclusive)
 z.loc[2:5]
```
::: 

#### By position
Indexing by position means we want to select data from our series based on where it is within the series. 

We can access a value by position using the `iloc` method. `iloc` stands for *integer-location based indexing*. This is the same kind of indexing we do in 1-dimensional numpy arrays or lists, where we use integers to access elements in the array and the index starts from 0.


```{python}
# initialize series
s = pd.Series(np.arange(10,13), index=['a','b','c'])
print(s, '\n')

# access element at index 2 (third element in series)
s.iloc[2]
```


If we try to use `iloc` with a label from our index we will get an error. Notice the TypeError: *Cannot index by location with a non-integer key*. 

![. ](/images/lesson-2/iloc_error.png)

::: {.callout-caution}
## `iloc` vs. `loc`
At the beginning the difference between `iloc` and `loc` can be confusing. Remember the `i` in `iloc` stands for integer-location, so this function only uses integers to retrieve information from the series. Moreover, remember `iloc` indexing works in the same way as indexing for Python lists.

If you want to dive deeper, this is a great discussion about the difference between `iloc` and `loc`: [Stackoverflow - How are iloc and loc different?](https://stackoverflow.com/questions/31593201/how-are-iloc-and-loc-different/31593712#31593712)
:::

## Data Frames

The Data Frame is the most used `pandas` object. It represents tabular data and we can think of it as a spreadhseet. Each column of a `pandas.DataFrame` is a `pandas.Series`. 

### Creating a `pandas.DataFrame`
There are [many ways of creating a `pandas.DataFrame`](https://pandas.pydata.org/docs/user_guide/dsintro.html#dataframe). Although we likely won't be creating data frames from scratch often, I'd like to go over creating a `pandas.DataFrame` from a `dict` of `pandas.Series` as this will help us understand the syntax for other Data Frame methods. 

We already mentioned each column of a `pandas.DataFrame` is a `pandas.Series`. In fact, the `pandas.DataFrame` is a dictionary of `pandas.Series`, with each column name being the key and the column values being the key's value. Thus, we can create a `pandas.DataFrame` in this way:

```{python}
# initialize dictionary with columns' data 
d = {'col_name_1' : pd.Series(np.arange(3)),
     'col_name_2' : pd.Series([3.1, 3.2, 3.3]),
     }

# create data frame
df = pd.DataFrame(d)
df
``` 

We can change the index and column names by changing the `index` and `columns` attributes in the data frame. 

```{python}
# print original index
print(df.index)

# change the index
df.index = ['a','b','c']
df
```

```{python}
# print original column names
print(df.columns)

# change column names 
df.columns = ['C1','C2']
df
```

## Subsetting a `pandas.DataFrame`

Like it's often the case when working with `pandas`, there are *many* ways in which we can subset a data frame. We will review the core methods to do this. 

There are two ways to subset data in a Data Frame: by position and by label. 

* **Subsetting by label** means we want to select data from our data frame using the *names* of the columns or the index.

* **Subsetting by position** means we want to select data from our data frame based on the data's *order* in the data frame.

Let's dive into some methods for subsetting which will clarify these options. For all examples we will use simplified data (glacial_loss.csv) from the National Snow and Ice Data Center (Dataset DOI:!​[](​http://dx.doi.org/10.7265/N52N506F)). The column descriptions are:

- **year**: ​calendar year
- **europe - antarctica**: ​change in glacial volume (km3​ ​) in each region that year
- **global_glacial_volume_change**: ​cumulative​ global glacial volume change (km3),
starting in 1961
- **annual_sea_level_rise**: ​annual rise in sea level (mm)
- **cumulative_sea_level_rise**:​ cumulative rise in sea level (mm) since 1961

```{python}
# read in file
df = pd.read_csv('data/lesson-1/glacial_loss.csv')

# see the first five rows
df.head()
```

First, we can get some baisc information about this data frame:

```{python}
# print column names
print(df.columns)

# print shape: output is a tupe (# rows, # columns)
print(df.shape)
```

### Selecting a single column...

#### ...by label
This is the simplest case for selecting data. Remember we can think of a `pandas.DataFrame` as a dictionary of its columns? Then we can access a single column using the column name as the key, just like we would do in a dictionary:

I'm interested in the annual sea level rise. 
```{python}
# seelect a single column by using square brackets []
annual_rise = df['annual_sea_level_rise']

# check the type of the ouput
print(type(annual_rise))

annual_rise.head()
```

Since we only selected a single column the output is a `pandas.Series`. 

We can also access a single column by using attribute syntax:

```{python}
annual_rise_2 = df.annual_sea_level_rise
annual_rise_2.head()
```

##### ...by position
Suppose we want to access the 10th column in the data frame - then we want to select a column by position. In this case the 10th column is the annual sea level rise data and the 10th position corresponds to the index 9. We can select this column by position using the `iloc` method*:

```{python}
# select column by position using iloc
# the syntax is iloc[rows,columns]
# [:,9] means "select all rows from the 10th column"
annual_rise_3 = df.iloc[:,9]
annual_rise_3.head()
```

:::{.callout-warning}
## Do not do that!
Unless you are really looking for information about *the 10th column*, do not access a column by position. This is bound to break in many ways:

- it relies on a person correctly counting the position of a column. Even with a small dataset this can be prone to error.

- it is not explicit: if we wnat information about sea level rise `df.annual_sea_level_rise` or `df['annual_sea_level_rise']` are explicitely telling us we are accessing that information. `df.iloc[:,9]` is obscure and uninformative.

- datastets can get updated. Maybe a new column was added before `annual_sea_level_rise`, this would change the position of the column, which would make any code depnding on `df.iloc[:,9]` invalid. Accessing by label helps reproducibility!

:::

### Selecting multiple columns...

#### ... using a list of column names

#### ... using a slice

#### ... using a condition


### Selecting rows

#### ... by label

#### ... by position

#### ... using a condition



<!--
This is not an exhaustive list of methods to select data, [it can get quite fancy.](https://pandas.pydata.org/docs/user_guide/indexing.html#selection-by-label)
-->


## Basic Matplotlib

## Resources

📖 [Pandas documentation - User Guide](https://pandas.pydata.org/docs/user_guide/index.html)

📖 [Python for Data Analysis, 3E - Getting started with pandas](https://wesmckinney.com/book/pandas-basics)



CONTINUE:
https://pandas.pydata.org/docs/user_guide/dsintro.html
https://pandas.pydata.org/docs/getting_started/intro_tutorials/03_subset_data.html
https://wesmckinney.com/book/pandas-basics
https://pandas.pydata.org/docs/user_guide/indexing.html#selection-by-label
https://earth-env-data-science.github.io/lectures/pandas/basic_pandas.html